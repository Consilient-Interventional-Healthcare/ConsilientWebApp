using System;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using Nuke.Common.IO;
using Serilog;

/// <summary>
/// Merges REST API types and GraphQL types into a single TypeScript file.
/// REST types are kept in their existing namespaces, GraphQL types are wrapped
/// in an 'export namespace GraphQL' block.
/// </summary>
public static class TypeScriptMerger
{
    private const string Header = @"//----------------------
// <auto-generated>
//     Combined REST API and GraphQL types
//     Generated using NUKE build system
//
//     This file was automatically generated. Do not modify manually.
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
";

    /// <summary>
    /// Merges REST API types and GraphQL types into a single output file.
    /// </summary>
    /// <param name="restTypesFile">Path to the REST API types file (namespaced)</param>
    /// <param name="graphqlTypesFile">Path to the GraphQL types file (to be wrapped in namespace)</param>
    /// <param name="outputFile">Path for the merged output file</param>
    public static void Merge(AbsolutePath restTypesFile, AbsolutePath graphqlTypesFile, AbsolutePath outputFile)
    {
        if (!File.Exists(restTypesFile))
        {
            throw new FileNotFoundException($"REST types file not found: {restTypesFile}");
        }

        if (!File.Exists(graphqlTypesFile))
        {
            throw new FileNotFoundException($"GraphQL types file not found: {graphqlTypesFile}");
        }

        Log.Information("Merging TypeScript types...");
        Log.Debug("  REST types: {File}", restTypesFile.Name);
        Log.Debug("  GraphQL types: {File}", graphqlTypesFile.Name);

        var restContent = File.ReadAllText(restTypesFile);
        var graphqlContent = File.ReadAllText(graphqlTypesFile);

        // Extract the REST namespaces (skip the header comments)
        var restNamespaces = ExtractNamespaces(restContent);

        // Wrap GraphQL types in namespace
        var wrappedGraphQL = WrapInNamespace("GraphQL", graphqlContent);

        // Build the merged file
        var sb = new StringBuilder();
        sb.AppendLine(Header);
        sb.AppendLine();
        sb.AppendLine("// ============================================");
        sb.AppendLine("// REST API Types");
        sb.AppendLine("// ============================================");
        sb.AppendLine();
        sb.AppendLine(restNamespaces);
        sb.AppendLine();
        sb.AppendLine("// ============================================");
        sb.AppendLine("// GraphQL Types");
        sb.AppendLine("// ============================================");
        sb.AppendLine();
        sb.AppendLine(wrappedGraphQL);

        // Ensure output directory exists
        outputFile.Parent.CreateDirectory();
        File.WriteAllText(outputFile, sb.ToString());

        var fileSize = new FileInfo(outputFile).Length / 1024.0;
        Log.Information("Types merged: {File} ({Size:N1} KB)", outputFile.Name, fileSize);
    }

    /// <summary>
    /// Extracts namespace declarations from the REST types file, skipping header comments.
    /// </summary>
    private static string ExtractNamespaces(string content)
    {
        // Find the first 'export namespace' and take everything from there
        var match = Regex.Match(content, @"^export namespace", RegexOptions.Multiline);
        if (match.Success)
        {
            return content.Substring(match.Index).TrimEnd();
        }

        // If no namespace found, return content without header comments
        var lines = content.Split('\n');
        var sb = new StringBuilder();
        var inHeader = true;

        foreach (var line in lines)
        {
            var trimmed = line.Trim();
            if (inHeader)
            {
                // Skip header lines (comments, eslint directives, empty lines at start)
                if (trimmed.StartsWith("//") || trimmed.StartsWith("/*") ||
                    trimmed.StartsWith("*") || trimmed == "" ||
                    trimmed.Contains("tslint:") || trimmed.Contains("eslint-"))
                {
                    continue;
                }
                inHeader = false;
            }
            sb.AppendLine(line);
        }

        return sb.ToString().TrimEnd();
    }

    /// <summary>
    /// Wraps TypeScript content in an export namespace block.
    /// Converts top-level exports to namespace members.
    /// </summary>
    private static string WrapInNamespace(string namespaceName, string content)
    {
        var lines = content.Split('\n');
        var sb = new StringBuilder();
        sb.AppendLine($"export namespace {namespaceName} {{");

        foreach (var line in lines)
        {
            var trimmed = line.Trim();

            // Skip header comments and directives
            if (trimmed.StartsWith("//") || trimmed.StartsWith("/*") ||
                trimmed.StartsWith("*") || trimmed.Contains("*/") ||
                trimmed.Contains("tslint:") || trimmed.Contains("eslint-") ||
                trimmed.Contains("ReSharper"))
            {
                continue;
            }

            // Skip empty lines at the beginning
            if (trimmed == "" && sb.Length < 50)
            {
                continue;
            }

            // Indent content
            if (trimmed != "")
            {
                sb.AppendLine("  " + line.TrimEnd());
            }
            else
            {
                sb.AppendLine();
            }
        }

        sb.AppendLine("}");
        return sb.ToString().TrimEnd();
    }
}
