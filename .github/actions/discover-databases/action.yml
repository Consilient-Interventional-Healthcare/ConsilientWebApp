name: 'Discover Databases with Configuration'
description: 'Scan directory for databases with optional configuration file filtering'

inputs:
  scripts_path:
    description: 'Root path to database scripts (e.g., src/Databases)'
    required: true
  config_file_name:
    description: 'Name of configuration file to look for (optional - if empty, discovers all directories)'
    required: false
    default: ''
  require_config:
    description: 'If true, only include directories with config file. If false, include all directories.'
    required: false
    default: 'false'

outputs:
  databases:
    description: 'JSON array of discovered databases with all metadata'
    value: ${{ steps.discover.outputs.databases }}
  database_directories:
    description: 'JSON array of database directory names (for databases.yml)'
    value: ${{ steps.transform.outputs.database_directories }}
  database_configs:
    description: 'JSON object mapping database names to config data (for docs_db.yml)'
    value: ${{ steps.transform.outputs.database_configs }}
  count:
    description: 'Number of databases discovered'
    value: ${{ steps.discover.outputs.count }}

runs:
  using: 'composite'
  steps:
    - name: Validate inputs
      shell: bash
      run: |
        set -e

        echo "üîç Database Discovery Configuration"
        echo "   Scripts path: ${{ inputs.scripts_path }}"
        echo "   Config file: ${{ inputs.config_file_name || '(none - discover all)' }}"
        echo "   Require config: ${{ inputs.require_config }}"
        echo ""

        # Validate scripts_path exists
        if [ ! -d "${{ inputs.scripts_path }}" ]; then
          echo "‚ùå ERROR: Scripts path not found: ${{ inputs.scripts_path }}"
          echo ""
          echo "‚ÑπÔ∏è  Available paths in repository root:"
          ls -la . | grep -E "^d" | awk '{print "   - " $NF}'
          echo ""
          echo "Please ensure the scripts_path input is correct and the directory exists."
          exit 1
        fi

        echo "‚úÖ Scripts path validated"

    - name: Discover databases
      id: discover
      shell: bash
      run: |
        set -e
        set -o pipefail

        SCRIPTS_PATH="${{ inputs.scripts_path }}"
        CONFIG_FILE="${{ inputs.config_file_name }}"
        REQUIRE_CONFIG="${{ inputs.require_config }}"

        # Change to scripts path with error handling
        if ! cd "$SCRIPTS_PATH" 2>&1; then
          echo "‚ùå ERROR: Failed to change directory to $SCRIPTS_PATH"
          echo "   This can occur if:"
          echo "   1. The path does not exist"
          echo "   2. The path is not accessible"
          echo "   3. The path contains spaces or special characters not properly quoted"
          exit 1
        fi

        echo "üìÅ Scanning for database directories in: $SCRIPTS_PATH"

        # Find all directories (depth 1)
        if ! ALL_DIRS=$(find . -mindepth 1 -maxdepth 1 -type d 2>&1 | sed 's|^\./||' | sort); then
          echo "‚ùå ERROR: Failed to search for directories"
          echo "   Permission denied or invalid path"
          exit 1
        fi

        if [ -z "$ALL_DIRS" ]; then
          echo "‚ö†Ô∏è  No directories found in $SCRIPTS_PATH"
          echo 'databases=[]' >> $GITHUB_OUTPUT
          echo 'count=0' >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "   Found $(echo "$ALL_DIRS" | wc -l) director(ies)"

        # Build JSON array with metadata
        DB_ARRAY="[]"
        COUNT=0

        while IFS= read -r dir; do
          [ -z "$dir" ] && continue

          CONFIG_PATH="$dir/$CONFIG_FILE"

          # If config file specified, check for its existence
          if [ -n "$CONFIG_FILE" ]; then
            if [ -f "$CONFIG_PATH" ]; then
              echo "‚úÖ $dir - config found: $CONFIG_FILE"

              # Parse config and build metadata object
              # Note: This uses yq if available, falls back to simple parsing
              if command -v yq &> /dev/null; then
                # Extract metadata using yq
                DB_NAME=$(yq eval '.database.name // "'"$dir"'"' "$CONFIG_PATH" 2>/dev/null || echo "$dir")
                GENERATE_DOCS=$(yq eval '.database.generate_docs // true' "$CONFIG_PATH" 2>/dev/null || echo "true")

                # Skip if generate_docs is false
                if [ "$GENERATE_DOCS" = "false" ]; then
                  echo "   ‚è≠Ô∏è  Skipping $dir - generate_docs: false"
                  continue
                fi

                # Create database object with metadata
                FULL_CONFIG_PATH="$SCRIPTS_PATH/$CONFIG_PATH"
                DB_OBJ=$(jq -n \
                  --arg directory "$dir" \
                  --arg name "$DB_NAME" \
                  --arg config_path "$FULL_CONFIG_PATH" \
                  '{directory: $directory, name: $name, config_path: $config_path, has_config: true}')
              else
                # Fallback without yq - just use directory name
                echo "   ‚ö†Ô∏è  yq not available - using basic parsing"
                FULL_CONFIG_PATH="$SCRIPTS_PATH/$CONFIG_PATH"
                DB_OBJ=$(jq -n \
                  --arg directory "$dir" \
                  --arg config_path "$FULL_CONFIG_PATH" \
                  '{directory: $directory, name: $directory, config_path: $config_path, has_config: true}')
              fi

              if ! DB_ARRAY=$(echo "$DB_ARRAY" | jq --argjson obj "$DB_OBJ" '. += [$obj]' 2>&1); then
                echo "‚ùå ERROR: Failed to add database object to array"
                echo "   JSON: $DB_OBJ"
                exit 1
              fi
              COUNT=$((COUNT + 1))
            else
              if [ "$REQUIRE_CONFIG" = "true" ]; then
                echo "‚è≠Ô∏è  Skipping $dir - no config file: $CONFIG_FILE"
              else
                echo "‚ö†Ô∏è  $dir - no config, including anyway (require_config: false)"
                DB_OBJ=$(jq -n \
                  --arg directory "$dir" \
                  '{directory: $directory, name: $directory, has_config: false}')
                if ! DB_ARRAY=$(echo "$DB_ARRAY" | jq --argjson obj "$DB_OBJ" '. += [$obj]' 2>&1); then
                  echo "‚ùå ERROR: Failed to add database object to array"
                  echo "   JSON: $DB_OBJ"
                  exit 1
                fi
                COUNT=$((COUNT + 1))
              fi
            fi
          else
            # No config file specified - include all directories
            echo "‚úÖ $dir - included (no config filter)"
            DB_OBJ=$(jq -n \
              --arg directory "$dir" \
              '{directory: $directory, name: $directory, has_config: false}')
            if ! DB_ARRAY=$(echo "$DB_ARRAY" | jq --argjson obj "$DB_OBJ" '. += [$obj]' 2>&1); then
              echo "‚ùå ERROR: Failed to add database object to array"
              echo "   JSON: $DB_OBJ"
              exit 1
            fi
            COUNT=$((COUNT + 1))
          fi
        done <<< "$ALL_DIRS"

        echo ""
        echo "üìä Discovery Summary:"
        echo "   Total directories: $(echo "$ALL_DIRS" | wc -l)"
        echo "   Databases to process: $COUNT"
        echo ""

        # Output results (use -c flag to ensure compact JSON on a single line for GitHub Actions compatibility)
        echo "databases=$(echo "$DB_ARRAY" | jq -c .)" >> $GITHUB_OUTPUT
        echo "count=$COUNT" >> $GITHUB_OUTPUT

        if [ "$COUNT" -gt 0 ]; then
          echo "‚úÖ Discovered databases:"
          echo "$DB_ARRAY" | jq -r '.[] | "   - \(.directory) (\(.name))"'
        else
          echo "‚ö†Ô∏è  No databases discovered"
        fi

    - name: Transform data for downstream workflows
      id: transform
      shell: bash
      run: |
        set -e

        DATABASES='${{ steps.discover.outputs.databases }}'

        # Validate that DATABASES is valid JSON
        if ! echo "$DATABASES" | jq empty 2>/dev/null; then
          echo "‚ùå ERROR: Invalid JSON from discovery step"
          echo "   Database JSON: $DATABASES"
          exit 1
        fi

        # Format 1: Array of full directory paths for databases.yml
        if ! DIRECTORIES=$(echo "$DATABASES" | jq -c '[.[] | .directory]' 2>&1); then
          echo "‚ùå ERROR: Failed to extract directory paths"
          exit 1
        fi
        echo "database_directories=$DIRECTORIES" >> $GITHUB_OUTPUT

        # Format 2: Object mapping names to config data for docs_db.yml
        # Important: Use -c flag to ensure compact JSON output on a single line
        CONFIGS="{}"
        while IFS= read -r db_entry; do
          if [ -z "$db_entry" ]; then
            continue
          fi

          if ! DB_NAME=$(echo "$db_entry" | jq -r '.name' 2>&1); then
            echo "‚ùå ERROR: Failed to extract database name from entry: $db_entry"
            exit 1
          fi

          if ! CONFIG_DATA=$(echo "$db_entry" | jq -c '{directory: .directory, config_path: .config_path}' 2>&1); then
            echo "‚ùå ERROR: Failed to extract config data from entry: $db_entry"
            exit 1
          fi

          if ! CONFIGS=$(echo "$CONFIGS" | jq -c --argjson data "$CONFIG_DATA" --arg name "$DB_NAME" '.[$name] = $data' 2>&1); then
            echo "‚ùå ERROR: Failed to add config to output object"
            echo "   Name: $DB_NAME"
            echo "   Data: $CONFIG_DATA"
            exit 1
          fi
        done < <(echo "$DATABASES" | jq -c '.[]')

        echo "database_configs=$CONFIGS" >> $GITHUB_OUTPUT
