name: 'Lighthouse Health Check'
description: 'Run Lighthouse performance checks on web app with automatic rollback on failure'

inputs:
  app-url:
    description: 'Application URL to check (e.g., https://myapp.azurewebsites.net)'
    required: true
  app-name:
    description: 'Azure Web App name'
    required: true
  client-id:
    description: 'Azure Service Principal Client ID'
    required: true
  tenant-id:
    description: 'Azure Tenant ID'
    required: true
  subscription-id:
    description: 'Azure Subscription ID'
    required: true
  client-secret:
    description: 'Azure Client Secret for local testing (act environment)'
    required: false
    default: ''
  resource-group:
    description: 'Azure Resource Group name (required for rollback)'
    required: false
  previous-image:
    description: 'Previous container image for rollback'
    required: false
  acr-registry:
    description: 'Azure Container Registry URL'
    required: false
  wait-seconds:
    description: 'Seconds to wait for deployment to stabilize'
    required: false
    default: '45'
  runs:
    description: 'Number of Lighthouse runs'
    required: false
    default: '3'
  min-perf-score:
    description: 'Minimum performance score (0-100)'
    required: false
    default: '0.7'
  min-a11y-score:
    description: 'Minimum accessibility score (0-100)'
    required: false
    default: '0.9'
  min-bp-score:
    description: 'Minimum best practices score (0-100)'
    required: false
    default: '0.7'
  min-seo-score:
    description: 'Minimum SEO score (0-100)'
    required: false
    default: '0.7'
  environment:
    description: 'Deployment environment (dev/prod)'
    required: false
    default: 'prod'

outputs:
  lighthouse-result:
    description: 'Lighthouse check result (passed/failed)'
    value: ${{ steps.lighthouse.outputs.result }}

runs:
  using: 'composite'
  steps:
    - name: Wait for Deployment
      shell: bash
      run: |
        max_wait=${{ inputs.wait-seconds }}
        interval=5
        elapsed=0
        app_url="${{ inputs.app-url }}"

        echo "‚è≥ Polling for app readiness (max $max_wait seconds)..."

        # Poll until app is ready or max wait reached
        while [ $elapsed -lt $max_wait ]; do
          http_code=$(curl -s -o /dev/null -w "%{http_code}" -m 5 "$app_url" 2>/dev/null || echo "000")

          if [ "$http_code" = "200" ]; then
            echo "‚úÖ App ready after ${elapsed}s (HTTP 200)"
            exit 0
          else
            echo "  Attempt at ${elapsed}s: HTTP $http_code (retrying in ${interval}s...)"
          fi

          sleep $interval
          elapsed=$((elapsed + interval))
        done

        echo "‚è≥ Max wait time reached after ${max_wait}s. Proceeding with health checks."

    - name: Verify App is Responding (Fail Fast)
      id: app_health_check
      shell: bash
      run: |
        app_url="${{ inputs.app-url }}"
        http_code=$(curl -s -o /dev/null -w "%{http_code}" "$app_url" 2>/dev/null || echo "000")

        if [ "$http_code" = "200" ]; then
          echo "‚úÖ App returning HTTP 200 - proceeding with Lighthouse"
          exit 0
        else
          echo "‚ùå App returned HTTP $http_code - failing fast"
          echo "Skipping Lighthouse checks due to app unavailability"
          exit 1
        fi

    - name: Run Lighthouse and Verify
      id: lighthouse_verify
      continue-on-error: true
      uses: treosh/lighthouse-ci-action@v10
      with:
        urls: |
          ${{ inputs.app-url }}
        temporaryPublicStorage: true
        runs: ${{ inputs.runs }}
      env:
        LHCI_ASSERT__ASSERTIONS__CATEGORIES_PERFORMANCE: '["error", {"minScore": ${{ inputs.min-perf-score }}}]'
        LHCI_ASSERT__ASSERTIONS__CATEGORIES_ACCESSIBILITY: '["error", {"minScore": ${{ inputs.min-a11y-score }}}]'
        LHCI_ASSERT__ASSERTIONS__CATEGORIES_BEST_PRACTICES: '["warn", {"minScore": ${{ inputs.min-bp-score }}}]'
        LHCI_ASSERT__ASSERTIONS__CATEGORIES_SEO: '["warn", {"minScore": ${{ inputs.min-seo-score }}}]'

    - name: Log Lighthouse Results
      shell: bash
      if: steps.lighthouse_verify.outcome == 'success'
      run: |
        echo "‚úÖ Lighthouse checks passed"
        echo "  Minimum Performance Score: ${{ inputs.min-perf-score }}"
        echo "  Minimum Accessibility Score: ${{ inputs.min-a11y-score }}"
        echo "  Minimum Best Practices Score: ${{ inputs.min-bp-score }}"
        echo "  Minimum SEO Score: ${{ inputs.min-seo-score }}"

    - name: Login to Azure for Rollback (OIDC + act fallback)
      if: steps.lighthouse_verify.outcome == 'failure' && inputs.resource-group != '' && inputs.environment != 'dev'
      uses: ./../../.github/actions/azure-login
      with:
        client-id: ${{ inputs.client-id }}
        tenant-id: ${{ inputs.tenant-id }}
        subscription-id: ${{ inputs.subscription-id }}
        client-secret: ${{ inputs.client-secret }}

    - name: Rollback Deployment
      if: steps.lighthouse_verify.outcome == 'failure' && inputs.resource-group != '' && inputs.environment != 'dev'
      shell: bash
      run: |
        echo "=== DEPLOYMENT ROLLBACK INITIATED ==="
        echo "Reason: Lighthouse checks failed"
        echo "App Name: ${{ inputs.app-name }}"
        echo "Resource Group: ${{ inputs.resource-group }}"
        echo "Previous Image: ${{ inputs.previous-image }}"

        # Verify we have a valid previous image
        PREVIOUS_IMAGE="${{ inputs.previous-image }}"

        if [ -z "$PREVIOUS_IMAGE" ] || [ "$PREVIOUS_IMAGE" = "false" ] || [ "$PREVIOUS_IMAGE" = "null" ] || [ "$PREVIOUS_IMAGE" = "none" ]; then
          echo ""
          echo "‚ö†Ô∏è  WARNING: No previous image available for rollback"
          echo ""
          echo "Current value: '$PREVIOUS_IMAGE'"
          echo ""
          echo "This may indicate:"
          echo "  - First deployment (no previous version exists)"
          echo "  - Previous image was not properly captured before deployment"
          echo "  - Azure Web App has no container configuration yet"
          echo ""
          echo "‚ùå Cannot rollback without a valid previous image"
          echo ""
          echo "NEXT STEPS:"
          echo "  1. Review deployment logs to find the root cause of the Lighthouse check failure"
          echo "  2. Fix the underlying issue (performance, accessibility, etc.)"
          echo "  3. Redeploy with the corrected code/configuration"
          echo "  4. If this is dev environment, deployment will continue despite check failure"
          exit 1
        fi

        echo "üîÑ Rolling back to previous image..."
        az webapp config container set \
          --name "${{ inputs.app-name }}" \
          --resource-group "${{ inputs.resource-group }}" \
          --docker-custom-image-name "${{ inputs.previous-image }}" \
          --docker-registry-server-url "https://${{ inputs.acr-registry }}"

        echo "üîÑ Restarting application..."
        az webapp restart \
          --name "${{ inputs.app-name }}" \
          --resource-group "${{ inputs.resource-group }}"

        sleep 20

        CURRENT_IMAGE=$(az webapp config container show \
          --name "${{ inputs.app-name }}" \
          --resource-group "${{ inputs.resource-group }}" \
          --query '[0].value' -o tsv)

        echo "Current Image: ${CURRENT_IMAGE}"
        echo "‚úÖ Rollback completed"

    - name: Verify Rollback - Quick Health Check After Rollback
      if: steps.lighthouse_verify.outcome == 'failure' && inputs.resource-group != '' && inputs.environment != 'dev'
      shell: bash
      run: |
        echo "üîç Verifying previous image is accessible after rollback..."
        echo ""
        echo "‚è≥ Waiting 30 seconds for previous image to stabilize..."
        sleep 30

        # Quick health check with retries (max 3 attempts, 10s delay)
        MAX_ATTEMPTS=3
        ATTEMPT=1
        SUCCESS=false

        while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
          echo "üìä Accessibility check attempt $ATTEMPT/$MAX_ATTEMPTS..."

          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "${{ inputs.app-url }}" 2>/dev/null || echo "000")

          if [ "$HTTP_CODE" = "200" ]; then
            echo "‚úÖ HTTP 200 received - Previous image is accessible"
            SUCCESS=true
            break
          else
            echo "‚ö†Ô∏è  HTTP $HTTP_CODE received"
          fi

          if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
            echo "‚è≥ Waiting 10 seconds before retry..."
            sleep 10
          fi

          ATTEMPT=$((ATTEMPT + 1))
        done

        echo ""
        if [ "$SUCCESS" = "true" ]; then
          echo "‚úÖ ROLLBACK VERIFIED: Previous image is accessible"
          exit 0
        else
          echo "‚ùå ROLLBACK INCOMPLETE: Previous image is NOT responding"
          echo "‚ö†Ô∏è  WARNING: Deployment rolled back but previous version is also inaccessible"
          echo "Manual intervention may be required"
          exit 1
        fi
