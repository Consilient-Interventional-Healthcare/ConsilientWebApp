name: "05 - Generate DB Docs"

# Runtime Dependencies
# This workflow requires the following tools to be available in the runner environment:
# - SchemaSpy JAR: /opt/schemaspy/schemaspy.jar (version controlled via SCHEMASPY_VERSION)
# - JDBC Driver: /opt/schemaspy/mssql-jdbc.jar (SQL Server driver)
# - Java: 17+ (for running SchemaSpy)
# - sqlcmd: Azure SQL command-line tool (for schema discovery)
# - jq: JSON query tool (for parsing JSON input)
# Note: These are typically pre-installed in GitHub Actions Ubuntu runners

on:
  workflow_call:
    inputs:
      database-configs:
        description: 'JSON array of database config objects (from centralized discovery in main.yml)'
        required: false
        type: string
        default: '[]'

permissions:
  contents: read
  # Uncomment these when enabling GitHub Pages deployment
  # pages: write
  # id-token: write

concurrency:
  group: generate-db-docs
  cancel-in-progress: false

env:
  SQL_SERVER: ${{ secrets.AZURE_SQL_SERVER }}
  SCHEMASPY_VERSION: ${{ vars.SCHEMASPY_VERSION || '6.2.4' }}
  JDBC_VERSION: ${{ vars.JDBC_DRIVER_VERSION || '12.4.2.jre11' }}
  SCHEMASPY_TIMEOUT_SECONDS: 600
  SCHEMA_DISCOVERY_TIMEOUT_SECONDS: 60

jobs:
  extract-databases:
    name: Extract Database Names
    runs-on: ubuntu-latest
    outputs:
      databases: ${{ steps.extract.outputs.databases }}
    steps:
      - name: Extract database names from config object
        id: extract
        run: |
          set -e

          CONFIGS='${{ inputs.database-configs }}'

          # Extract database names (keys) from the config object
          DB_NAMES=$(echo "$CONFIGS" | jq -c 'keys')
          echo "databases=$DB_NAMES" >> $GITHUB_OUTPUT

          echo "‚úÖ Extracted database names: $DB_NAMES"

  validate-prerequisites:
    name: Validate Workflow Prerequisites
    runs-on: ubuntu-latest
    steps:
      - name: Validate configuration
        run: |
          set -e

          echo "üîç Validating workflow prerequisites..."
          echo ""

          # Check SQL_SERVER is configured
          if [ -z "${{ env.SQL_SERVER }}" ]; then
            echo "‚ùå ERROR: AZURE_SQL_SERVER secret not configured"
            echo ""
            echo "This secret must be set in your repository settings or GitHub organization."
            echo "It should contain the FQDN of your Azure SQL Server (e.g., server.database.windows.net)"
            exit 1
          fi

          # Check required CLI tools are available
          REQUIRED_TOOLS=("sqlcmd" "jq" "java")
          for tool in "${REQUIRED_TOOLS[@]}"; do
            if ! command -v "$tool" &> /dev/null; then
              echo "‚ùå ERROR: Required tool not found: $tool"
              exit 1
            fi
          done

          echo "‚úÖ SQL Server configured: ${{ env.SQL_SERVER }}"
          echo "‚úÖ All required CLI tools available (sqlcmd, jq, java)"
          echo ""
          echo "üéØ Prerequisites validation passed"

  generate-db-docs:
    name: Generate Docs for ${{ matrix.database }}
    needs: [extract-databases, validate-prerequisites]
    runs-on: ubuntu-latest
    timeout-minutes: 25
    strategy:
      matrix:
        database: ${{ fromJson(needs.extract-databases.outputs.databases) }}
      fail-fast: false

    env:
      DATABASE_NAME: ${{ matrix.database }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Validate database name
        run: |
          set -e

          DATABASE_NAME="${{ matrix.database }}"

          # Validate database name matches safe pattern (alphanumeric, underscore, hyphen only)
          if [[ ! "$DATABASE_NAME" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "‚ùå ERROR: Invalid database name: '$DATABASE_NAME'"
            echo "Database names must contain only alphanumeric characters, underscores, and hyphens."
            exit 1
          fi

          echo "‚úÖ Database name validated: $DATABASE_NAME"

      - name: Parse database configuration
        id: parse-config
        run: |
          set -e

          echo "üìã Parsing configuration for ${{ matrix.database }}"

          SCHEMAS_TO_EXCLUDE=""

          # Extract config file path for this database (from centralized discovery)
          CONFIG_DATA=$(echo '${{ inputs.database-configs }}' | jq -r '.["${{ matrix.database }}"]')

          if [ "$CONFIG_DATA" != "null" ] && [ -n "$CONFIG_DATA" ]; then
            CONFIG_PATH=$(echo "$CONFIG_DATA" | jq -r '.config_path')

            if [ -f "$CONFIG_PATH" ]; then
              CONFIG_FILE="$CONFIG_PATH"
              echo "‚úÖ Found config: $CONFIG_FILE"

              # Install yq if not available
              if ! command -v yq &> /dev/null; then
                echo "üì¶ Installing yq..."
                sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
                sudo chmod +x /usr/local/bin/yq
              fi

              # Parse schemas to exclude
              EXCLUDE_LIST=$(yq eval '.schemas.exclude // []' "$CONFIG_FILE" | yq eval '.[]' - 2>/dev/null | tr '\n' ',' | sed 's/,$//')
              if [ -n "$EXCLUDE_LIST" ]; then
                SCHEMAS_TO_EXCLUDE="$EXCLUDE_LIST"
                echo "üö´ Schemas to exclude: $SCHEMAS_TO_EXCLUDE"
              fi
            else
              echo "‚ö†Ô∏è  Config file not found: $CONFIG_FILE - using defaults"
            fi
          else
            echo "‚ö†Ô∏è  No config data found for ${{ matrix.database }} - using defaults"
          fi

          # Export exclusions for use in subsequent steps
          echo "SCHEMAS_TO_EXCLUDE=$SCHEMAS_TO_EXCLUDE" >> $GITHUB_ENV

          echo "‚úÖ Configuration parsing complete"

      - name: Login to Azure (OIDC + act fallback)
        uses: ./.github/actions/azure-login
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure-credentials: ${{ secrets.AZURE_CREDENTIALS || '{}' }}

      - name: Discover database schemas
        id: discover-schemas
        run: |
          set -e
          set -o pipefail

          echo "üîç Discovering schemas in ${{ env.DATABASE_NAME }}..."

          # Path to discovery SQL script
          DISCOVERY_SQL="infra/db/list_user_schemas.sql"

          if [ ! -f "$DISCOVERY_SQL" ]; then
            echo "‚ùå ERROR: Schema discovery script not found: $DISCOVERY_SQL"
            exit 1
          fi

          # Execute query using sqlcmd with Azure AD authentication
          DISCOVERED_SCHEMAS=$(timeout ${{ env.SCHEMA_DISCOVERY_TIMEOUT_SECONDS }} sqlcmd \
            -S "${{ env.SQL_SERVER }}" \
            -d "${{ env.DATABASE_NAME }}" \
            -G \
            -i "$DISCOVERY_SQL" \
            -h -1 \
            -W \
            -b 2>schema_discovery_error.log || echo "")

          exit_code=$?

          # Handle discovery failures
          if [ $exit_code -ne 0 ]; then
            echo "‚ùå Schema discovery failed with exit code $exit_code"
            echo "--- Error output ---"
            cat schema_discovery_error.log 2>/dev/null || echo "No error log available"
            echo "-------------------"
            exit 1
          fi

          # Clean output (remove empty lines and trim whitespace)
          DISCOVERED_SCHEMAS=$(echo "$DISCOVERED_SCHEMAS" | grep -v "^[[:space:]]*$" | xargs)

          # Validate at least one schema was found
          if [ -z "$DISCOVERED_SCHEMAS" ]; then
            echo "‚ö†Ô∏è  WARNING: No user schemas discovered in database ${{ env.DATABASE_NAME }}"
            echo "This could indicate:"
            echo "  1. The database has no user-created schemas"
            echo "  2. Authentication/permission issues"
            echo "  3. The database is empty or newly created"
            echo ""
            echo "Skipping documentation generation for this database."
            echo "SKIP_DOCUMENTATION=true" >> $GITHUB_ENV
            exit 0
          fi

          echo "‚úÖ Discovered schemas: $DISCOVERED_SCHEMAS"
          echo "DISCOVERED_SCHEMAS=$DISCOVERED_SCHEMAS" >> $GITHUB_ENV

          # Count schemas
          SCHEMA_COUNT=$(echo "$DISCOVERED_SCHEMAS" | wc -w)
          echo "üìä Total schemas found: $SCHEMA_COUNT"

      - name: Initialize and validate configuration
        run: |
          set -e

          # Check if documentation should be skipped
          if [ "${{ env.SKIP_DOCUMENTATION }}" = "true" ]; then
            echo "‚è≠Ô∏è  Skipping documentation - no schemas to document"
            exit 0
          fi

          # Use discovered schemas from previous step
          SCHEMAS_TO_DOC="${{ env.DISCOVERED_SCHEMAS }}"

          # Validate we have schemas to document
          if [ -z "$SCHEMAS_TO_DOC" ]; then
            echo "‚ùå ERROR: No schemas available for documentation"
            echo "This is unexpected - the discovery step should have caught this."
            exit 1
          fi

          # Filter out excluded schemas if provided
          if [ -n "${{ env.SCHEMAS_TO_EXCLUDE }}" ]; then
            echo "üìã Applying schema exclusions: ${{ env.SCHEMAS_TO_EXCLUDE }}"

            # Convert comma-separated exclusions to array
            IFS=',' read -ra EXCLUDE_ARRAY <<< "${{ env.SCHEMAS_TO_EXCLUDE }}"

            # Build exclusion pattern
            EXCLUDE_PATTERN=""
            for exclude_schema in "${EXCLUDE_ARRAY[@]}"; do
              exclude_schema=$(echo "$exclude_schema" | xargs)
              [ -z "$exclude_schema" ] && continue
              EXCLUDE_PATTERN="$EXCLUDE_PATTERN|$exclude_schema"
            done

            # Remove leading pipe
            EXCLUDE_PATTERN="${EXCLUDE_PATTERN#|}"

            # Filter schemas (case-insensitive) only if pattern is not empty
            if [ -n "$EXCLUDE_PATTERN" ]; then
              FILTERED_SCHEMAS=""
              for schema in $SCHEMAS_TO_DOC; do
                if ! echo "$schema" | grep -iE "^($EXCLUDE_PATTERN)$" > /dev/null; then
                  FILTERED_SCHEMAS="$FILTERED_SCHEMAS $schema"
                else
                  echo "üö´ Excluding schema: $schema"
                fi
              done
            else
              # No patterns to exclude, keep all schemas
              FILTERED_SCHEMAS="$SCHEMAS_TO_DOC"
            fi

            SCHEMAS_TO_DOC="$(echo $FILTERED_SCHEMAS | xargs)"

            # Check if all schemas were excluded
            if [ -z "$SCHEMAS_TO_DOC" ]; then
              echo "‚ö†Ô∏è  WARNING: All discovered schemas were excluded"
              echo "Discovered: ${{ env.DISCOVERED_SCHEMAS }}"
              echo "Excluded: ${{ env.SCHEMAS_TO_EXCLUDE }}"
              echo "SKIP_DOCUMENTATION=true" >> $GITHUB_ENV
              exit 0
            fi

            echo "‚úÖ Filtered schemas: $SCHEMAS_TO_DOC"
          fi

          # Export for use in subsequent steps
          echo "SCHEMAS_TO_DOC=$SCHEMAS_TO_DOC" >> $GITHUB_ENV

          echo "‚úÖ Configuration validated"
          echo "Database: ${{ env.DATABASE_NAME }}"
          echo "SQL Server: ${{ env.SQL_SERVER }}"
          echo "Schemas to document: $SCHEMAS_TO_DOC"

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Generate schema documentation (parallel)
        id: schema-doc
        if: env.SKIP_DOCUMENTATION != 'true'
        run: |
          set -e
          set -o pipefail

          # Common SchemaSpy parameters to reduce duplication
          # -t: Database type (MSSQL 2017+)
          # -norows: Skip row count (faster)
          # -vizjs: Use viz.js for diagrams (no Graphviz needed)
          # -imageformat svg: Use SVG for better quality
          # -noimplied: Don't show implied relationships
          SCHEMASPY_COMMON="-t mssql17 \
            -dp /opt/schemaspy/mssql-jdbc.jar \
            -host ${{ env.SQL_SERVER }} \
            -db ${{ env.DATABASE_NAME }} \
            -u unused \
            -connprops \"authenticationScheme\\=ActiveDirectoryDefault;encrypt\\=true;trustServerCertificate\\=false\" \
            -norows \
            -vizjs \
            -imageformat svg \
            -noimplied"

          # Create output directories dynamically
          DIRS_TO_CREATE=""
          for schema in ${SCHEMAS_TO_DOC}; do
            schema=$(echo "$schema" | xargs)
            [ -z "$schema" ] && continue
            schema_lower=$(echo "$schema" | tr '[:upper:]' '[:lower:]')
            DIRS_TO_CREATE="$DIRS_TO_CREATE docs/$schema_lower"
          done

          mkdir -p $DIRS_TO_CREATE

          echo "üöÄ Starting parallel schema documentation generation for ${{ env.DATABASE_NAME }}..."
          echo "Schemas to document: ${SCHEMAS_TO_DOC}"

          # Track PIDs for parallel execution
          declare -a PIDS
          declare -a SCHEMA_NAMES
          declare -a START_TIMES

          # Generate documentation for each schema in parallel
          for schema in ${SCHEMAS_TO_DOC}; do
            schema=$(echo "$schema" | xargs)
            [ -z "$schema" ] && continue
            schema_lower=$(echo "$schema" | tr '[:upper:]' '[:lower:]')

            # Get description or use default
            DESCRIPTION="${SCHEMA_DESCRIPTIONS[$schema]:-$schema Schema Documentation}"

            START_TIME=$(date +%s)
            CURRENT_TIME=$(date -u '+%H:%M:%S UTC')
            echo "üìä [$CURRENT_TIME] Starting $schema schema generation (timeout: ${{ env.SCHEMASPY_TIMEOUT_SECONDS }}s)..."
            timeout ${{ env.SCHEMASPY_TIMEOUT_SECONDS }} java -jar /opt/schemaspy/schemaspy.jar $SCHEMASPY_COMMON \
              -o docs/$schema_lower \
              -s $schema \
              -desc "$DESCRIPTION" &

            PIDS+=($!)
            SCHEMA_NAMES+=("$schema")
            START_TIMES+=("$START_TIME")
          done

          # Wait for all processes and check exit codes
          TOTAL_TASKS=${#PIDS[@]}
          echo ""
          echo "‚è≥ Waiting for $TOTAL_TASKS documentation task(s) to complete..."

          for i in "${!PIDS[@]}"; do
            pid="${PIDS[$i]}"
            name="${SCHEMA_NAMES[$i]}"
            start_time="${START_TIMES[$i]}"

            CURRENT_TIME=$(date -u '+%H:%M:%S UTC')
            echo "‚è≥ [$CURRENT_TIME] Waiting for $name schema generation (PID: $pid)..."
            if wait "$pid"; then
              end_time=$(date +%s)
              elapsed=$((end_time - start_time))
              echo "‚úÖ $name schema complete (elapsed: ${elapsed}s)"
            else
              echo "‚ùå $name schema failed with exit code: $?"
              exit 1
            fi
          done

          echo ""
          echo "üéâ All schema documentation generated successfully for ${{ env.DATABASE_NAME }}"

      - name: Cleanup on failure
        if: failure() && steps.schema-doc.outcome == 'failure'
        run: |
          echo "üßπ Cleaning up partial documentation due to schema generation failure..."
          rm -rf docs/
          echo "‚úÖ Cleanup complete - partial docs removed"
          echo ""
          echo "### ‚ùå Schema Documentation Generation Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Database**: ${{ env.DATABASE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Reason**: One or more schemas failed to generate documentation." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**To diagnose:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Check the 'Generate Schema Documentation' step logs above" >> $GITHUB_STEP_SUMMARY
          echo "2. Look for schema-specific error messages (‚ùå marks)" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify SchemaSpy timeout limits and database connectivity" >> $GITHUB_STEP_SUMMARY

      - name: Create enhanced index page
        if: steps.schema-doc.outcome == 'success'
        env:
          DB_NAME: ${{ env.DATABASE_NAME }}
        run: |
          set -e
          set -o pipefail

          # HTML escape function to prevent injection attacks
          escape_html() {
            local input="$1"
            input="${input//&/&amp;}"
            input="${input//</&lt;}"
            input="${input//>/&gt;}"
            input="${input//\"/&quot;}"
            input="${input//$'\x27'/&#39;}"
            echo "$input"
          }

          # Use variables directly - no heredoc quoting to allow substitution
          CURRENT_DATE=$(date -u '+%Y-%m-%d %H:%M:%S UTC')

          # Generate schema cards HTML from SCHEMAS_TO_DOC
          SCHEMA_CARDS=""
          for schema in ${SCHEMAS_TO_DOC}; do
            schema=$(echo "$schema" | xargs) # trim whitespace
            [ -z "$schema" ] && continue
            schema_lower=$(echo "$schema" | tr '[:upper:]' '[:lower:]')

            # Use defaults for all metadata (no custom metadata supported in minimal config)
            ICON="üì¶"
            TITLE="$schema Schema"
            DESC="Documentation for the $schema schema."

            # Escape all dynamic content to prevent HTML injection
            ICON_ESCAPED=$(escape_html "$ICON")
            TITLE_ESCAPED=$(escape_html "$TITLE")
            DESC_ESCAPED=$(escape_html "$DESC")
            SCHEMA_LOWER_ESCAPED=$(escape_html "$schema_lower")

            # Build card HTML with escaped content
            CARD="<div class=\"schema-card\">
                          <h2>$ICON_ESCAPED $TITLE_ESCAPED</h2>
                          <p>$DESC_ESCAPED</p>"

            CARD="$CARD
                          <a href=\"./$SCHEMA_LOWER_ESCAPED/index.html\" class=\"btn\">View $TITLE_ESCAPED Schema ‚Üí</a>
                      </div>
                      "

            SCHEMA_CARDS="$SCHEMA_CARDS$CARD"
          done

          cat > docs/index.html << EOF
          <!DOCTYPE html>
          <html lang="en">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Consilient Database Documentation</title>
              <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üè•</text></svg>">
              <style>
                  :root {
                      --primary-color: #3498db;
                      --primary-dark: #2980b9;
                      --background: #f5f5f5;
                      --card-background: #ffffff;
                      --text-primary: #2c3e50;
                      --text-secondary: #7f8c8d;
                      --border-radius: 8px;
                      --shadow: 0 2px 4px rgba(0,0,0,0.1);
                      --shadow-hover: 0 4px 8px rgba(0,0,0,0.15);
                  }
                  
                  * {
                      margin: 0;
                      padding: 0;
                      box-sizing: border-box;
                  }
                  
                  body {
                      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
                      line-height: 1.6;
                      color: var(--text-primary);
                      background: var(--background);
                  }
                  
                  .container {
                      max-width: 1200px;
                      margin: 0 auto;
                      padding: 2rem;
                  }
                  
                  .header {
                      background: var(--card-background);
                      padding: 2rem;
                      border-radius: var(--border-radius);
                      box-shadow: var(--shadow);
                      margin-bottom: 2rem;
                  }
                  
                  h1 {
                      color: var(--text-primary);
                      margin-bottom: 0.5rem;
                      font-size: 2.5rem;
                  }
                  
                  .subtitle {
                      color: var(--text-secondary);
                      font-size: 1.1rem;
                      margin-bottom: 1.5rem;
                  }
                  
                  .info-grid {
                      display: grid;
                      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                      gap: 1rem;
                      background: #e8f4f8;
                      padding: 1.5rem;
                      border-radius: var(--border-radius);
                  }
                  
                  .info-item {
                      display: flex;
                      flex-direction: column;
                  }
                  
                  .info-label {
                      font-weight: 600;
                      color: var(--text-secondary);
                      font-size: 0.85rem;
                      text-transform: uppercase;
                      letter-spacing: 0.5px;
                      margin-bottom: 0.25rem;
                  }
                  
                  .info-value {
                      color: var(--text-primary);
                      font-size: 1rem;
                      word-break: break-word;
                  }
                  
                  .schema-grid {
                      display: grid;
                      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                      gap: 1.5rem;
                      margin-top: 2rem;
                  }
                  
                  .schema-card {
                      background: var(--card-background);
                      padding: 1.5rem;
                      border-radius: var(--border-radius);
                      box-shadow: var(--shadow);
                      transition: all 0.3s ease;
                      border-left: 4px solid var(--primary-color);
                  }
                  
                  .schema-card:hover {
                      transform: translateY(-4px);
                      box-shadow: var(--shadow-hover);
                  }
                  
                  .schema-card h2 {
                      color: var(--primary-color);
                      margin-bottom: 0.75rem;
                      font-size: 1.5rem;
                  }
                  
                  .schema-card p {
                      color: var(--text-secondary);
                      margin-bottom: 1rem;
                  }
                  
                  .schema-card ul {
                      list-style: none;
                      margin-bottom: 1rem;
                  }
                  
                  .schema-card li {
                      padding: 0.25rem 0;
                      color: var(--text-secondary);
                  }
                  
                  .schema-card li:before {
                      content: "‚ñ™";
                      color: var(--primary-color);
                      font-weight: bold;
                      display: inline-block;
                      width: 1em;
                      margin-left: 0.5em;
                  }
                  
                  .btn {
                      display: inline-block;
                      margin-top: 1rem;
                      padding: 0.75rem 1.5rem;
                      background: var(--primary-color);
                      color: white;
                      text-decoration: none;
                      border-radius: var(--border-radius);
                      font-weight: 500;
                      transition: background 0.3s ease;
                  }
                  
                  .btn:hover {
                      background: var(--primary-dark);
                  }
                  
                  @media (max-width: 768px) {
                      .container {
                          padding: 1rem;
                      }
                      
                      h1 {
                          font-size: 2rem;
                      }
                      
                      .schema-grid {
                          grid-template-columns: 1fr;
                      }
                  }
              </style>
          </head>
          <body>
              <div class="container">
                  <div class="header">
                      <h1>üè• Consilient Database Documentation</h1>
                      <p class="subtitle">Auto-generated database schema documentation for the Consilient Healthcare System</p>
                      <div class="info-grid">
                          <div class="info-item">
                              <span class="info-label">Last Updated</span>
                              <span class="info-value">${CURRENT_DATE}</span>
                          </div>
                          <div class="info-item">
                              <span class="info-label">Database</span>
                              <span class="info-value">${DB_NAME}</span>
                          </div>
                      </div>
                  </div>

                  <div class="schema-grid">
                      $SCHEMA_CARDS
                  </div>
              </div>
          </body>
          </html>
          EOF

      - name: Generate summary
        if: steps.schema-doc.outcome == 'success'
        run: |
          echo "## üìö Database Documentation Generated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Documentation successfully generated and uploaded as artifact" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì• How to View" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to the **Summary** tab of this workflow run" >> $GITHUB_STEP_SUMMARY
          echo "2. Download the **database-documentation** artifact" >> $GITHUB_STEP_SUMMARY
          echo "3. Extract the ZIP file" >> $GITHUB_STEP_SUMMARY
          echo "4. Open **index.html** in your browser" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Schemas Documented" >> $GITHUB_STEP_SUMMARY

          for schema in ${SCHEMAS_TO_DOC}; do
            schema=$(echo "$schema" | xargs)
            [ -z "$schema" ] && continue
            ICON="üì¶"
            DESC="Schema documentation"
            echo "- $ICON **$schema** - $DESC" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Database Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Database**: ${{ env.DATABASE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Deployed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> üí° **Tip**: Once GitHub Pages is enabled, uncomment the Pages deployment steps in this workflow" >> $GITHUB_STEP_SUMMARY

      - name: Prepare artifact metadata
        id: artifact-meta
        if: steps.schema-doc.outcome == 'success'
        run: |
          set -e

          # Determine artifact suffix based on event type
          ARTIFACT_SUFFIX="latest"
          RETENTION_DAYS=30

          case "${{ github.event_name }}" in
            pull_request)
              ARTIFACT_SUFFIX="pr-${{ github.event.pull_request.number }}"
              RETENTION_DAYS=7
              ;;
            workflow_call)
              ARTIFACT_SUFFIX="latest"
              RETENTION_DAYS=30
              ;;
            workflow_dispatch)
              ARTIFACT_SUFFIX="manual-$(date +%s)"
              RETENTION_DAYS=30
              ;;
          esac

          echo "suffix=$ARTIFACT_SUFFIX" >> $GITHUB_OUTPUT
          echo "retention=$RETENTION_DAYS" >> $GITHUB_OUTPUT
          echo "Artifact suffix: $ARTIFACT_SUFFIX (retention: $RETENTION_DAYS days)"

      - name: Upload documentation as artifact
        if: steps.schema-doc.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: database-documentation-${{ matrix.database }}-${{ steps.artifact-meta.outputs.suffix }}
          path: ./docs
          retention-days: ${{ steps.artifact-meta.outputs.retention }}
          if-no-files-found: error
